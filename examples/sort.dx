'## Stack operations.
This is a fake stack for now until Dex gets dependent dereferencing,
or can handle nested references.

bufsize = 1000

data Stack a:Type h:Type =
  AsStack size: (Ref h Int) buf: (Ref h ((Fin bufsize)=>a))

def pop (stack:Stack a h) : {State h} Maybe a =
  (AsStack size buf) = stack
  case get size == 0 of
    True -> Nothing
    False ->
      size := (get size) - 1
      Just (get buf!((get size)@_))

def push (stack:Stack b h) (x:b) : {State h} Unit =
  (AsStack size buf) = stack
  buf!((get size)@_) := x
  size := (get size) + 1

def empty (stack:Stack b h) : {State h} Bool =
  (AsStack size buf) = stack
  (get size) <= 0

-- This will be a nice helper function, but for now it doesn't
-- typecheck due to a unification bug.
def withStack
      (init:t)
      (action: (Stack t h -> {State h |eff} Unit))
      : {|eff} Unit =
  withState (1, for i:(Fin bufsize). init) \pairref.
    stack = AsStack (fstRef pairref) (sndRef pairref)
    action stack
  ()


'## Generic helper functions

def swapInRef (xsRef: Ref h (n=>t)) (a:n) (b:n) : {State h} Unit =
  temp     = get xsRef!a
  xsRef!a := get xsRef!b
  xsRef!b := temp

def (-|) (i:n) (delta:Int) : n =
  i' = ordinal i - delta
  fromOrdinal _ $ select (i' < 0) 0 i'

def (+|) (i:n) (delta:Int) : n =
  i' = ordinal i + delta
  fromOrdinal _ $ select (i' >= size n) (size n - 1) i'

def firstIx (n:Type) : n = 0@n
def lastIx  (n:Type) : n = ((size n) - 1)@n


data MyRange a:Type =
  MkRange low:a high:a

def rangeSize (MkRange low high:MyRange a) : Int =
  1 + ordinal high - ordinal low


'# Sort functions

def partition [Ord a] (xsRef: Ref h (n=>a))
  (MkRange low high:MyRange n) : {State h} n = 
  -- Chooses the last element as the pivot, then
  -- moves all elements smaller than the pivot to its left,
  -- and all elements greater to the right.  Operates in place
  -- and returns the final location of the pivot.
    pivotval = get xsRef!high
    
    final_pivot_ix = yieldState low \pivotIxRef.
      for j':(low..<high).
        j = %inject j'
        case get xsRef!j < pivotval of
          True ->
            swapInRef xsRef (get pivotIxRef) j
            pivotIxRef := (get pivotIxRef) +| 1
          False -> ()
    swapInRef xsRef final_pivot_ix high 
    final_pivot_ix

def quickSortInPlace [Ord a] (xsRef: Ref h (n=>a)) : {State h} Unit =
  initrange = MkRange (firstIx n) (lastIx n)
  runState (1, for i:(Fin bufsize). initrange) \pairref.
    stack = AsStack (fstRef pairref) (sndRef pairref)
    while do 
      case pop stack of
        Nothing -> False
        Just cur_range -> 
          case rangeSize cur_range <= 1 of
            True -> ()
            False ->
              pivot_ix = partition xsRef cur_range
              (MkRange low high) = cur_range

              left_range  = MkRange low (pivot_ix -| 1)
              right_range = MkRange (pivot_ix +| 1) high

              push stack left_range
              push stack right_range
          True
  ()

def sort [Ord a] (xs:n=>a) : n=>a =
  yieldState xs quickSortInPlace

def isSorted [Ord a] (xs:n=>a) : Bool =
  all for i. xs.i <= xs.(i +| 1)

---------- Tests -----------

:p isSorted $ sort [9, 3, 7, 4, 6, 1, 9, 1, 9, -1, 10, 10, 100, 0]
> True
