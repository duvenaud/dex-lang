'# General Linear Maps
Often when writing numerical code, there are efficient specializations for
e.g. diagonal matrices, lower-triangular, or sparse matrices.
I'd like to be able to write just one version of this code without having to
fall back to casting everything to full-rank unstructured matrices.
This example is for brainstorming how the typeclass system might support
efficient polymorphism for linear algebra over different types of
structured maps.

import linalg

'Todo: factor out a more general linear map typeclass, and make this one inherit from it.

-- interface [VSpace m, VSpace in, VSpace out] LinearMap m in out
  -- apply: m -> in -> out
  -- transpose': m -> m

'## Linear Endomorphisms
a.k.a. linear maps from a space back to that same space.

interface HasDeterminant m
  determinant': m -> Float
  transposeType m : Type  -- unused for now
  transpose': m -> m      -- In future: m -> transposeType m
  identity': m

interface [VSpace v, HasDeterminant m] LinearEndo m v
  apply: m -> v -> v
  diag: m -> v
  solve': m -> v -> v

'We'd like to remove `v` from the `LinearEndo` interface,
and instead use associated types to specify a `v` for each `m`.
This would let use combine it with `HasDeterminant`.
But for now, fields in typeclasses can't refer to one another.
This means that `determinant'` and other operations can't be part
of this typeclass yet, because `v` is always ambiguous at its usage site.


'## Instances

'### Scalar maps

data ScalarMap =
  MkScalarMap Float

instance HasDeterminant ScalarMap
  determinant' = \(MkScalarMap a). a
  transposeType = Float
  transpose' = id
  identity' = MkScalarMap 1.0

instance {v} [Mul v, VSpace v] LinearEndo ScalarMap v
  apply =  \(MkScalarMap a) b. a .* b
  diag =   \(MkScalarMap a).   a .* one
  solve' = \(MkScalarMap a) b. b / a

instance Arbitrary ScalarMap
  arb = \k. MkScalarMap $ arb k


'### Diagonal maps

data DiagMap n [Ix n] =
  MkDiagMap (i:n=>Float)

instance {n} HasDeterminant (DiagMap n)
  determinant' = \(MkDiagMap x). prod x
  transposeType = n=>Float
  transpose' = id
  identity' = MkDiagMap one

instance {n v} [Mul v, VSpace v] LinearEndo (DiagMap n) (n=>v)
  apply =  \(MkDiagMap x) y. for i. x.i .* y.i
  diag =   \(MkDiagMap a).   for i. a.i .* one
  solve' = \(MkDiagMap a) b. for i. b.i / a.i

instance {n} Arbitrary (DiagMap n)
  arb = \k. MkDiagMap $ arb k


'### Full-rank matrices.
I didn't use a newtype for these, but I'm not sure if that's the right call.

instance {n} HasDeterminant (n=>n=>Float)
  determinant' = determinant
  transposeType = n=>n=>Float
  transpose' = transpose
  identity' = eye

instance {n v} [Mul v, VSpace v] LinearEndo (n=>n=>Float) (n=>v)
  apply = \x y. for i. sum for j. x.i.j .* y.j
  diag = \x. for i. x.i.i .* one
  solve' = solve


'### Lower-triangular maps

data LowerTriMap n [Ix n] =
  MkLowerTriMap (i:n=>(..i)=>Float)

instance {n} HasDeterminant (LowerTriMap n)
  determinant' = \(MkLowerTriMap x). prod $ lower_tri_diag x
  transposeType = UpperTriMat n Float
  transpose' = error "Can't transpose to different types yet."
  identity' = MkLowerTriMap for i j. select (ordinal i == ordinal j) one zero

instance {n v} [Mul v, VSpace v] LinearEndo (LowerTriMap n) (n=>v)
  apply  = \(MkLowerTriMap x) y. for i. sum for j. x.i.j .* y.(%inject j)
  diag   = \(MkLowerTriMap x).   for i. x.i.(cast i) .* one
  solve' = \(MkLowerTriMap x).   forward_substitute x

instance {n} Arbitrary (LowerTriMap n)
  arb = \k. MkLowerTriMap $ arb k


'### Upper-triangular maps

data UpperTriMap n [Ix n] =
  MkUpperTriMap (i:n=>(i..)=>Float)

instance {n} HasDeterminant (UpperTriMap n)
  determinant' = \(MkUpperTriMap x). prod $ upper_tri_diag x
  transposeType = LowerTriMat n Float
  transpose' = error "Can't transpose to different types yet."
  identity' = MkUpperTriMap for i j. select (0 == ordinal j) one zero

instance {n v} [Mul v, VSpace v] LinearEndo (UpperTriMap n) (n=>v)
  apply  = \(MkUpperTriMap x) y. for i. sum for j. x.i.j .* y.(%inject j)
  diag   = \(MkUpperTriMap x).   for i. x.i.(0@_) .* one
  solve' = \(MkUpperTriMap x).   backward_substitute x

instance {n} Arbitrary (UpperTriMap n)
  arb = \k. MkUpperTriMap $ arb k


'### Skew-symmetric maps

data SkewSymmetricMap n [Ix n] =
  MkSkewSymMap (i:n=>(..<i)=>Float)

instance {n} HasDeterminant (SkewSymmetricMap n)
  determinant' = case is_odd (size n) of
    True -> zero
    False -> \(MkSkewSymMap a).
      dense_rep = skew_symmetric_prod a eye
      determinant dense_rep  -- Naive algorithm, could be done with Pfaffian
  transposeType = i:n=>(..<i)=>Float
  transpose' = \(MkSkewSymMap x). MkSkewSymMap (-x)
  identity' = error "Skew symmetric matrices can't represent the identity map."

instance {n v} [Mul v, VSpace v] LinearEndo (SkewSymmetricMap n) (n=>v)
  apply  = \(MkSkewSymMap x) y. skew_symmetric_prod x y
  diag   = \(MkSkewSymMap x).   zero
  solve' = \(MkSkewSymMap x) y.
    dense_rep = skew_symmetric_prod x eye  -- Fall back to naive algorithm
    solve dense_rep y

instance {n} Arbitrary (SkewSymmetricMap n)
  arb = \k. MkSkewSymMap $ arb k


-- Todo: Sparse matrices. Need hashmaps for these to be practical.



'## Application 1: Gaussians

-- This typeclass will be obsolete once the `Basis` typeclass can be written.
interface HasStandardNormal a:Type
  randNormal : Key -> a

instance HasStandardNormal Float32
  randNormal = randn
instance {a n} [HasStandardNormal a] HasStandardNormal (n=>a)
  randNormal = \key.
    for i. randNormal (ixkey key i)


def gaussianSample {v m} [VSpace v, LinearEndo m v, HasStandardNormal v]
                   ((mean, covroot) : (v & m)) (key:Key) : v =
  noise = randNormal key
  mean + apply covroot noise

:p gaussianSample (1.0, (MkScalarMap 2.0)) (new_key 0)


'### Generic log pdf of a multivariate Gaussian
This single definition of a Gaussian log pdf should work
efficiently for any type of covariance matrix for which
an efficient solve and determinant is known.

-- This helper will be osbolete once the basis typeclass works.
def get_VSpace_dim {v} [InnerProd v, Mul v, VSpace v] (x:v) : Float =
  one' : v = one
  inner_prod one' one'

def gaussianlogpdf {m v}
    [VSpace v, Mul v, InnerProd v, LinearEndo m v]
    (mean:v) (covroot:m) (x:v) : Float =
  dim = get_VSpace_dim x
  squarepart = inner_prod (x - mean) (solve' (transpose' covroot)
                                     (solve'             covroot (x - mean)))
  const = dim * log (2.0 * pi) + log (sq (determinant' covroot))
  -0.5 * (squarepart + const)




'## Tests


vec_len = (Fin 4)
full_mat_type = (vec_len=>vec_len=>Float)
v = vec_len=>Float

'### Check application of the identity is a no-op.

def check_identity (m:Type)
    [LinearEndo m v, HasDeterminant m, Arbitrary m] : Bool =
  i : m = identity'
  vec : v = (arb $ new_key 0)
  vec ~~ apply i vec

check_identity $ LowerTriMap vec_len
> True
check_identity $ UpperTriMap vec_len
> True
check_identity $ vec_len=>vec_len=>Float
> True
check_identity $ DiagMap vec_len
> True
check_identity $ ScalarMap
> True

def check_inverse (m:Type) [LinearEndo m v, Arbitrary m, LinearEndo m full_mat_type] : Bool =
  a : m   = arb $ new_key 0
  vec : v = arb $ new_key 0
  inv  : full_mat_type = solve' a eye
  full : full_mat_type = apply  a eye
  apply inv full ~~ eye

check_inverse $ SkewSymmetricMap vec_len
> True
check_inverse $ LowerTriMap vec_len
> True
check_inverse $ UpperTriMap vec_len
> True
check_inverse $ vec_len=>vec_len=>Float
> True
check_inverse $ DiagMap vec_len
> True
check_inverse ScalarMap
> True


def check_transpose (m:Type)
    [LinearEndo m v, HasDeterminant m, Arbitrary m] : Bool =
  a : m                  = arb $ new_key 0
  (vec1, vec2) : (v & v) = arb $ new_key 1
  
  hitleft  = inner_prod (apply a vec1) vec2
  hitright = inner_prod (apply (transpose' a) vec2) vec1
  hitleft ~~ hitright

check_transpose $ SkewSymmetricMap vec_len
> True
-- check_transpose $ LowerTriMap vec_len
-- > True
-- check_transpose $ UpperTriMap vec_len
-- > True
check_transpose $ vec_len=>vec_len=>Float
> True
check_transpose $ DiagMap vec_len
> True
check_transpose ScalarMap
> True

-- Check that 1D Gaussian sums to 1
sizen = Fin 2000
span = 10.0
xs = linspace sizen (-span) span
integral = 2.0 * span * mean for i.
  exp $ gaussianlogpdf (-0.1) (MkScalarMap 0.07) xs.i
integral ~~ 1.0
> True

def check_2D_Gaussian_normalizes (m:Type)
    [LinearEndo m ((Fin 2) => Float32), Arbitrary m] : Bool =

  sizen = Fin 200
  span = 10.0
  xs = linspace sizen (-span) span

  covroot : m = arb $ new_key 0
  meanvec : ((Fin 2) => Float32) = arb $ new_key 1
  integral = (sq (2.0 * span)) * mean for (i, j):(sizen & sizen).
    x = [xs.i, xs.j]
    exp $ gaussianlogpdf meanvec covroot x
  integral ~~ 1.0

check_2D_Gaussian_normalizes (SkewSymmetricMap (Fin 2))
> True
-- check_2D_Gaussian_normalizes (LowerTriMat (Fin 2) Float)
-- > True
-- check_2D_Gaussian_normalizes (UpperTriMat (Fin 2) Float)
-- > True
check_2D_Gaussian_normalizes $ (Fin 2)=>(Fin 2)=>Float
> True
check_2D_Gaussian_normalizes $ DiagMap (Fin 2)
> True


'## Application 2: SDEs

Time = Float
def radonNikodym {m s} [InnerProd s, VSpace s, LinearEndo m s]
                 (drift1: s->Time->s)
                 (drift2: s->Time->s)
                 (diffusion: s->Time->m)
                 (state: s) (t: Time) : Float =
  -- Dynamics of simple Monte Carlo estimatr of KL divergence between
  -- two SDEs that share a diffusion function. (If not, divergence is infinite)
  difference = (drift1 state t) - (drift2 state t)
  cur_diffusion = diffusion state t
  a = solve' cur_diffusion difference
  0.5 * inner_prod a a


-- Drift and diffusion product.
-- DiffusionProd takes state and noise and returns dstate/dtime
def Drift (v:Type) [VSpace v]: Type = v->Time->v
def Diffusion (m:Type) (v:Type) [VSpace m, VSpace v] : Type = v->Time->(LinearEndo m v)
def DiffusionProd (v:Type) : Type = v->Time->v->v
def SDE (m:Type) (v:Type) [VSpace m, VSpace v] : Type = ((Drift v) & (DiffusionProd v))

def SkewSymmetricProd (v:Type) : Type = v->Time->v->v

def NegEnergyFunc (v:Type) : Type = v->Time->Float
def StationarySDE (v:Type) : Type = (NegEnergyFunc v & SkewSymmetricProd v & DiffusionProd v)

def stationary_SDE_to_SDE {m v} [Mul v, VSpace v, VSpace m] (sta:StationarySDE v) : (SDE m v) =
  -- From Section 2.1 of "A Complete Recipe for Stochastic Gradient MCMC"
  -- https://arxiv.org/pdf/1506.04696.pdf
  (negEnergyFunc, skewSymmetricProd, diffusionProd) = sta
  varProd = \state time vec.
    0.5 .* (diffusionProd state time $ diffusionProd state time vec)
  drift = \state time.
    curNE = \state. negEnergyFunc state time
    negenergygrad = (grad curNE) state
    t1 = (skewSymmetricProd + varProd) state time negenergygrad
    gammapart = \state. (skewSymmetricProd + varProd) state time one
    t3 = jvp gammapart state one
    t1 + t3
  (drift, diffusionProd)

-- Todo: tests for SDE functions.
