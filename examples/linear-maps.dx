import linalg

'## Instances for triangular tables
How to avoid these repetitive instances?

instance {a n} [Add a] Add (i:n => (..<i) => a)
  add = \xs ys. for i. xs.i + ys.i
  sub = \xs ys. for i. xs.i - ys.i
  zero = for _. zero

instance {a n} [Add a] Add (i:n => (i<..) => a)
  add = \xs ys. for i. xs.i + ys.i
  sub = \xs ys. for i. xs.i - ys.i
  zero = for _. zero

instance {a n} [VSpace a] VSpace (i:n => (..i) => a)
  scale_vec = \s xs. for i. s .* xs.i

instance {a n} [VSpace a] VSpace (i:n => (i..) => a)
  scale_vec = \s xs. for i. s .* xs.i

instance {a n} [VSpace a] VSpace (i:n => (..<i) => a)
  scale_vec = \s xs. for i. s .* xs.i

instance {a n} [VSpace a] VSpace (i:n => (i<..) => a)
  scale_vec = \s xs. for i. s .* xs.i

instance {n a} [Arbitrary a] Arbitrary (i:n=>(..<i) => a)
  arb = \x. for i. arb $ new_key (ordinal i)

instance {n a} [Arbitrary a] Arbitrary (i:n=>(..i) => a)
  arb = \x. for i. arb $ new_key (ordinal i)

instance {n a} [Arbitrary a] Arbitrary (i:n=>(i..) => a)
  arb = \x. for i. arb $ new_key (ordinal i)

instance {n a} [Arbitrary a] Arbitrary (i:n=>(i<..) => a)
  arb = \x. for i. arb $ new_key (ordinal i)


t = (i:(Fin 2)=> (..i) => Float32)
x : t = arb $ new_key 0

def f (g:t) : t =
  g

f x


'Todo: factor out a more general linear map typeclass, and make this one inherit from it.
-- interface [VSpace m, VSpace in, VSpace out] LinearMap m in out
  -- apply: m -> in -> out
  -- transpose': m -> m

'## Linear Endomorphisms
a.k.a. linear maps from a space back to that same space.


interface [VSpace m, VSpace v] LinearEndo m v
  apply: m -> v -> v
  -- determinant': m -> Float
  -- transposeType: Type
  -- transpose': m -> transposeType
  -- identity': m
  diag: m -> v
  solve': m -> v -> v

'We'd like to remove `v` from the above interface,
and instead use associated types to specify a `v` for each `m`.
But for now, fields in typeclasses can't refer to one another.
This means that `determinant'` can't be part of this typeclass yet,
because `v` is always ambiguous at its usage site.


instance {v} [Mul v, VSpace v] LinearEndo (Float) v
  apply = (.*)
  diag = \a. a .* one
  solve' = \a b. b / a

-- Diagonal matrices
instance {n v} [Mul v, VSpace v] LinearEndo (n=>Float) (n=>v)
  apply = \x y. for i. x.i .* y.i
  diag = \a. for i. a.i .* one
  solve' = \a b. for i. b.i / a.i

-- Full-rank matrices
instance {n v} [Mul v, VSpace v] LinearEndo (n=>n=>Float) (n=>v)
  apply = \x y. for i. sum for j. x.i.j .* y.j
  diag = \x. for i. x.i.i .* one
  solve' = solve

-- Lower-triangular matrices
instance {n v} [Mul v, VSpace v] LinearEndo (LowerTriMat n Float) (n=>v)
  apply = \x y. for i. sum for j. x.i.j .* y.(%inject j)
  diag = \x. for i. x.i.(cast i) .* one
  solve' = forward_substitute

-- Upper-triangular matrices
instance {n v} [Mul v, VSpace v] LinearEndo (UpperTriMat n Float) (n=>v)
  apply = \x y. for i. sum for j. x.i.j .* y.(%inject j)
  diag = \x. for i. x.i.(0@_) .* one
  solve' = backward_substitute


'### Skew symmetric matrices.
For now it's just a wrapper around lower triangular matrices with no diagonal
elements, but the danger is that something accidentally gets treated as a
skew-symmetric matrix. 

def SkewSymmetricMat (n:Type) [Ix n] (v:Type) : Type = i:n=>(..<i)=>v

def transpose_lower_to_upper' {n v}
    (lower:i:n=>(..<i)=>v) :
           i:n=>(i<..)=>v =
  for i j.
    j' = %inject j
    lower.j'.(unsafe_from_ordinal _ (ordinal i))

def skewSymmetricProd {v n} [VSpace v]
    (lower: i:n=>(..<i)=>Float) (y: n=>v) : n=>v =
  lower_prod = for i. sum for j. lower.i.j .* (y.(%inject j))
  upper = transpose_lower_to_upper' lower
  upper_prod = for i. sum for j. upper.i.j .* (y.(%inject j))
  lower_prod - upper_prod

instance {n v} [Mul v, VSpace v] LinearEndo (i:n=>(..<i)=>Float) (n=>v)
  apply = skewSymmetricProd
  diag = \x. zero
  solve' = \a y.
    dense_rep = skewSymmetricProd a eye  -- Fall back to naive algorithm
    solve dense_rep y

'### Sparse matrices.
def SparseMatrix (n:Type) (m:Type) [Ix n, Ix m] (v:Type) : Type = todo
def SquareSparseMatrix (n:Type) [Ix n] (v:Type) : Type = SparseMatrix n n v


'## Determinant and miscellaneous typeclass
This should probably be part of the `LinearEndo` typeclass,
once associated types work.

interface HasDeterminant m
  determinant': m -> Float
  transposeType m : Type  -- unused for now
  transpose': m -> m   -- In future: m -> transposeType
  identity': m

instance HasDeterminant Float
  determinant' = id
  transposeType = Float
  transpose' = id
  identity' = 1.0

-- Diagonal matrices
instance {n} HasDeterminant (n=>Float)
  determinant' = prod
  transposeType = n=>Float
  transpose' = id
  identity' = one

-- Full-rank matrices
instance {n} HasDeterminant (n=>n=>Float)
  determinant' = determinant
  transposeType = n=>n=>Float
  transpose' = transpose
  identity' = eye

-- Lower-triangular matrices
instance {n} HasDeterminant (LowerTriMat n Float)
  determinant' = \x. prod $ lower_tri_diag x
  transposeType = UpperTriMat n Float
  transpose' = error "Can't transpose to different types yet."
  identity' = for i j. select (ordinal i == ordinal j) one zero

-- Upper-triangular matrices
instance {n} HasDeterminant (UpperTriMat n Float)
  determinant' = \x. prod $ upper_tri_diag x
  transposeType = LowerTriMat n Float
  transpose' = error "Can't transpose to different types yet."
  identity' = for i j. select (0 == ordinal j) one zero

instance {n} HasDeterminant (i:n=>(..<i)=>Float)
  determinant' = case is_odd (size n) of
    True -> zero
    False -> \a.
      dense_rep = skewSymmetricProd a eye
      determinant dense_rep  -- Naive algorithm, could be done with Pfaffian
  transposeType = i:n=>(..<i)=>Float
  transpose' = \x. -x
  identity' = error "Skew symmetric matrices can't represent the identity map."


'## Inner product typeclass

interface [VSpace v] InnerProd v
  inner_prod : v->v->Float

instance InnerProd Float
  inner_prod = \x y. x * y

instance {a n} [InnerProd a] InnerProd (n=>a)
  inner_prod = \x y. sum for i. inner_prod x.i y.i


'## Application 1: Gaussians

-- This typeclass will be obsolete once the `Basis` typeclass can be written.
interface HasStandardNormal a:Type
  randNormal : Key -> a

instance HasStandardNormal Float32
  randNormal = randn
instance {a n} [HasStandardNormal a] HasStandardNormal (n=>a)
  randNormal = \key.
    for i. randNormal (ixkey key i)

def gaussianSample {v m} [VSpace v, VSpace m, LinearEndo m v, HasStandardNormal v]
                   ((mean, covroot) : (v & m)) (key:Key) : v =
  noise = randNormal key
  mean + apply covroot noise

:p gaussianSample (1.0, 2.0) (new_key 0)

'## Generic log pdf of a multivariate Gaussian
This single definition of a Gaussian log pdf should work
efficiently for any type of covariance matrix for which
an efficient solve and determinant is known.

-- This helper will be osbolete once the basis typeclass works.
def get_VSpace_dim {v} [InnerProd v, Mul v, VSpace v] (x:v) : Float =
  asdf : v = one
  inner_prod asdf asdf

def gaussianlogpdf {m v}
    [HasDeterminant m, VSpace m, Mul v, VSpace v, InnerProd v, LinearEndo m v]
    (mean:v) (covroot:m) (x:v) : Float =
  dim = get_VSpace_dim x
  squarepart = inner_prod (x - mean) (solve' (transpose' covroot) (solve' covroot (x - mean)))
  const = dim * log (2.0 * pi) + log (sq (determinant' covroot))
  -0.5 * (squarepart + const)


'## Application 2: SDEs

Time = Float
def radonNikodym {m s} [Mul s, VSpace s, LinearEndo m s]
                 (drift1: s->Time->s)
                 (drift2: s->Time->s)
                 (diffusion: s->Time->m)
                 (state: s) (t: Time) : s =
  -- Dynamics of simple Monte Carlo estimatr of KL divergence between
  -- two SDEs that share a diffusion function. (If not, divergence is infinite)
  sqd = sq ((drift1 state t) - (drift2 state t))
  solve' (diffusion state t) sqd


-- Drift and diffusion product.
-- DiffusionProd takes state and noise and returns dstate/dtime
def Drift (v:Type) [VSpace v]: Type = v->Time->v
def Diffusion (m:Type) (v:Type) [VSpace m, VSpace v] : Type = v->Time->(LinearEndo m v)
def DiffusionProd (v:Type) : Type = v->Time->v->v
def SDE (m:Type) (v:Type) [VSpace m, VSpace v] : Type = ((Drift v) & (DiffusionProd v))

def SkewSymmetricProd (v:Type) : Type = v->Time->v->v

def NegEnergyFunc (v:Type) : Type = v->Time->Float
def StationarySDE (v:Type) : Type = (NegEnergyFunc v & SkewSymmetricProd v & DiffusionProd v)

def stationary_SDE_to_SDE {m v} [Mul v, VSpace v, VSpace m] (sta:StationarySDE v) : (SDE m v) =
  -- From Section 2.1 of "A Complete Recipe for Stochastic Gradient MCMC"
  -- https://arxiv.org/pdf/1506.04696.pdf
  (negEnergyFunc, skewSymmetricProd, diffusionProd) = sta
  varProd = \state time vec.
    0.5 .* (diffusionProd state time $ diffusionProd state time vec)
  drift = \state time.
    curNE = \state. negEnergyFunc state time
    negenergygrad = (grad curNE) state
    t1 = (skewSymmetricProd + varProd) state time negenergygrad
    gammapart = \state. (skewSymmetricProd + varProd) state time one
    t3 = jvp gammapart state one
    t1 + t3
  (drift, diffusionProd)


'## Tests


vec_len = (Fin 4)
full_mat_type = (vec_len=>vec_len=>Float)

'### Check application of the identity is a no-op.

def check_identity (m:Type) (v:Type)
    [LinearEndo m v, HasDeterminant m, Arbitrary m, Arbitrary v,
     VSpace v, HasAllClose v, HasDefaultTolerance v] : Bool =
  i : m = identity'
  vec : v = (arb $ new_key 0)
  vec ~~ apply i vec

check_identity (LowerTriMat vec_len Float) (vec_len=>Float)
> True
check_identity (UpperTriMat vec_len Float) (vec_len=>Float)
> True
check_identity (vec_len=>vec_len=>Float) (vec_len=>Float)
> True
check_identity (vec_len=>Float) (vec_len=>Float)
> True
check_identity (Float) (vec_len=>Float)
> True

def check_inverse (m:Type) (v:Type)
    [LinearEndo m v, HasDeterminant m, Arbitrary m, Arbitrary v, LinearEndo m full_mat_type,
     VSpace v, HasAllClose v, HasDefaultTolerance v] : Bool =
  a : m   = (arb $ new_key 0)
  vec : v = (arb $ new_key 0)
  inv : full_mat_type = solve' a eye
  full : full_mat_type = apply a eye
  apply inv full ~~ eye

check_inverse (SkewSymmetricMat vec_len Float) (vec_len=>Float)
> True
check_inverse (LowerTriMat vec_len Float) (vec_len=>Float)
> True
check_inverse (UpperTriMat vec_len Float) (vec_len=>Float)
> True
check_inverse (vec_len=>vec_len=>Float) (vec_len=>Float)
> True
check_inverse (vec_len=>Float) (vec_len=>Float)
> True
check_inverse (Float) (vec_len=>Float)
> True


def check_transpose (m:Type) (v:Type)
    [LinearEndo m v, HasDeterminant m, Arbitrary m, Arbitrary v,
     VSpace v, HasAllClose v, HasDefaultTolerance v, InnerProd v] : Bool =
  a : m                  = arb $ new_key 0
  (vec1, vec2) : (v & v) = arb $ new_key 1
  
  hitleft = inner_prod (apply a vec1) vec2
  hitright = inner_prod (apply (transpose' a) vec2) vec1
  hitleft ~~ hitright

check_transpose (SkewSymmetricMat vec_len Float) (vec_len=>Float)
> True
-- check_transpose (LowerTriMat vec_len Float) (vec_len=>Float)
-- > True
-- check_transpose (UpperTriMat vec_len Float) (vec_len=>Float)
-- > True
check_transpose (vec_len=>vec_len=>Float) (vec_len=>Float)
> True
check_transpose (vec_len=>Float) (vec_len=>Float)
> True
check_transpose (Float) (vec_len=>Float)
> True

-- Check that 1D Gaussian sums to 1
sizen = Fin 2000
span = 10.0
xs = linspace sizen (-span) span
integral = 2.0 * span * mean for i.
  exp $ gaussianlogpdf (-0.1) 0.07 xs.i
integral ~~ 1.0

def check_2D_Gaussian_normalizes (m:Type)
    [LinearEndo m ((Fin 2) => Float32), HasDeterminant m, Arbitrary m] : Bool =

  sizen = Fin 200
  span = 10.0
  xs = linspace sizen (-span) span

  covroot : m = arb $ new_key 0
  meanvec : ((Fin 2) => Float32) = arb $ new_key 1
  integral = (sq (2.0 * span)) * mean for (i, j):(sizen & sizen).
    x = [xs.i, xs.j]
    exp $ gaussianlogpdf meanvec covroot x
  integral ~~ 1.0

check_2D_Gaussian_normalizes (SkewSymmetricMat (Fin 2) Float)
> True
-- check_2D_Gaussian_normalizes (LowerTriMat (Fin 2) Float)
-- > True
-- check_2D_Gaussian_normalizes (UpperTriMat (Fin 2) Float)
-- > True
check_2D_Gaussian_normalizes ((Fin 2)=>(Fin 2)=>Float)
> True
check_2D_Gaussian_normalizes ((Fin 2)=>Float)
> True

-- check_2D_Gaussian_normalizes (Float)  -- How does this even typecheck?
-- > True
