'Integrate systems of ordinary differential equations (ODEs) using the Dormand-Prince method for adaptive integration
stepsize calculation.


Time = Real

-- Should these go in the prelude?
def norm (x: d=>Real) : Real = sqrt $ sum for i. sq x.i
def (./) (x: d=>Real) (y: d=>Real) : d=>Real = for i. x.i / y.i

-- Todo: Add this general operation to prelude?  In Jax this is just dot.
def mydot (_:VSpace v) ?=> (s:d=>Real) (vs:d=>v) : v =
  sum for j. s.j .* vs.j
 
-- TODO: Replace these with 1e-x when Dex can parse it.
oneem3 = 0.001
oneem5 = 0.00001
oneem6 = 0.000001
oneem15 = 0.000000000000001

def fit_4th_order_polynomial (_:VSpace v) ?=>
    (z0:v) (z1:v) (z_mid:v) (dz0:v) (dz1:v) (dt:Time) : (Fin 5)=>v =
  a = -2.0 * dt .* dz0 + 2.0 * dt .* dz1 -  8.0 .* z0 -  8.0 .* z1 + 16.0 .* z_mid
  b =  5.0 * dt .* dz0 - 3.0 * dt .* dz1 + 18.0 .* z0 + 14.0 .* z1 - 32.0 .* z_mid
  c = -4.0 * dt .* dz0 +       dt .* dz1 - 11.0 .* z0 -  5.0 .* z1 + 16.0 .* z_mid
  d = dt .* dz0
  e = z0
  [a, b, c, d, e]

dps_c_mid = [6025192743.0 / 30085553152.0 / 2.0, 0.0, 51252292925.0 / 65400821598.0 / 2.0,
            -2691868925.0 / 45128329728.0 / 2.0, 187940372067.0 / 1594534317056.0 / 2.0,
            -1776094331.0 / 19743644256.0 / 2.0, 11237099.0 / 235043384.0 / 2.0]

def interp_fit_dopri (_:VSpace v) ?=> (z0:v) (z1:v) (k:(Fin 7)=>v) (dt:Time) : (Fin 5)=>v =
  -- Fit a polynomial to the results of a Runge-Kutta step.
  z_mid = z0 + dt .* (mydot dps_c_mid k)
  fit_4th_order_polynomial z0 z1 z_mid k.(0@_) k.(1@_) dt

def initial_step_size (fun:d=>Real -> Time -> d=>Real) (t0:Time) (z0:d=>Real)
                      (order:Int) (rtol:Real) (atol:Real) (f0:d=>Real) : Time =
  -- Algorithm from: E. Hairer, S. P. Norsett G. Wanner,
  -- Solving Ordinary Differential Equations I: Nonstiff Problems, Sec. II.4.
  scale = for i. atol + ((abs z0.i) * rtol)
  d0 = norm (z0 ./ scale)
  d1 = norm (f0 ./ scale)
  h0 = select ((d0 < oneem5) || (d1 < oneem5)) oneem6 (0.01 * (d0 / d1))
  z1 = z0 + h0 .* f0
  f1 = fun z1 (t0 + h0)
  d2 = (norm ((f1 - f0) ./ scale)) / h0
  left = max oneem6 (h0 * oneem3)
  right = pow (0.01 / (d1 + d2)) (1.0 / ((i2r order) + 1.0))
  h1 = select ((d1 <= oneem15) && (d2 <= oneem15)) left right
  min (100.0 * h0) h1

-- Dopri5 Butcher tableaux
alpha = [1.0 / 5.0, 3.0 / 10.0, 4.0 / 5.0, 8.0 / 9.0, 1., 1.]
-- Todo: convert beta to triangular array.
beta = [[1.0 / 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
       [3.0 / 40.0, 9.0 / 40.0, 0.0, 0.0, 0.0, 0.0, 0.0],
       [44.0 / 45.0, -56.0 / 15.0, 32.0 / 9.0, 0.0, 0.0, 0.0, 0.0],
       [19372.0 / 6561.0, -25360.0 / 2187.0, 64448.0 / 6561.0, -212.0 / 729.0, 0.0, 0.0, 0.0],
       [9017.0 / 3168.0, -355.0 / 33.0, 46732.0 / 5247.0, 49.0 / 176.0, -5103.0 / 18656.0, 0.0, 0.0],
       [35.0 / 384.0, 0.0, 500.0 / 1113.0, 125.0 / 192.0, -2187.0 / 6784.0, 11.0 / 84.0, 0.0]]
c_sol = [35.0 / 384.0, 0.0, 500.0 / 1113.0, 125.0 / 192.0, -2187.0 / 6784.0, 11.0 / 84.0, 0.0]
c_error = [35.0 / 384.0 - 1951.0 / 21600.0, 0.0, 500.0 / 1113.0 - 22642.0 / 50085.0,
                      125.0 / 192.0 - 451.0 / 720.0, -2187.0 / 6784.0 + 12231.0 / 42400.0,
                      11.0 / 84.0 - 649.0 / 6300.0, -1.0 / 60.0]

def runge_kutta_step (_:VSpace v) ?=> (func:v->Time->v)
    (z0:v) (f0:v) (t0:Time) (dt:Time) : (v & v & v & (Fin 7)=>v) =

  runge_kutta_stage = \i k.
    ti = t0 + dt .* alpha.i
    zi = z0 + dt .* (mydot beta.i k)
    func zi ti

  k_init = for i. select (i == (0@_)) f0 zero

  k_filled = snd $ withState k_init \k. for i.
    ft = runge_kutta_stage i (get k)
    k!(((ordinal i) + 1)@_) := ft

  z_last =  z0 + dt .* (mydot c_sol   k_filled)
  z_last_error = dt .* (mydot c_error k_filled)
  f_last = k_filled.(6@_)
  (z_last, f_last, z_last_error, k_filled)

def error_ratio (error_estimates:d=>Real) (rtol:Real) (atol:Real)
                (z0:d=>Real) (z1:d=>Real) : Real =
  err_tols = for i. atol + rtol * (max (abs z0.i) (abs z1.i))
  err_ratios = error_estimates ./ err_tols
  mean for i. sq err_ratios.i

def optimal_step_size (last_step:Time) (mean_error_ratio:Real) : Time =
  safety = 0.9
  ifactor = 10.0
  dfactor = 0.2
  order = 5.0
  dfactor = select (mean_error_ratio < 1.0) 1.0 dfactor
  err_ratio = sqrt mean_error_ratio
  factor = max (1.0 / ifactor) (min ( (pow err_ratio (1.0 / order)) / safety) (1.0 / dfactor))
  select (mean_error_ratio == 0.0) (last_step * ifactor) (last_step / factor)


-- State of solver: (next state, next f, next time, dt, t, interp coeffs)
-- def SolverState (v:Type) : Type = (v & v & Time & Time & Time & (Fin 5)=>v)
-- This ended up being unnecessary to spell anywhere, but was
-- useful for debugging.

def odeint (func: d=>Real -> Time -> d=>Real)
           (z0: d=>Real) (t0: Time) (times: n=>Time) : n=>d=>Real =
  -- Adaptive stepsize (Dormand-Prince) Runge-Kutta odeint implementation.
  --  Args:
  --    func: time derivative of the solution z at time t.
  --    z0: the initial value for the state.
  --    t: times for evaluation. values must be strictly increasing.
  --  Returns:
  --    Values of the solution at each time point in times.
  rtol = 0.000000014 -- relative local error tolerance for solver.
  atol = 0.000000014 -- absolute local error tolerance for solver.
  max_iters = 1000000

  integrate_to_next_time = \iter init_carry.
    target_t = times.iter

    stopping_condition = \(_, _, t, dt, _, _).
      (t < target_t) && (dt > 0.0) && (ordinal iter < max_iters)

    possible_step = \(z, f, t, dt, last_t, interp_coeff).
      (next_z, next_f, next_z_error, k) = runge_kutta_step func z f t dt
      next_t = t + dt
      ratio = error_ratio next_z_error rtol atol z next_z
      new_interp_coeff = interp_fit_dopri z next_z k dt
      new_dt = optimal_step_size dt ratio

      move_state = (next_z, next_f, next_t, new_dt,      t, new_interp_coeff)
      stay_state = (     z,      f,      t, new_dt, last_t,     interp_coeff)
      select (ratio <= 1.0) move_state stay_state

    -- Take steps until we pass target_t
    new_state = snd $ withState init_carry \state.
      while (\(). stopping_condition (get state)) \().
        state := possible_step (get state)
    (_, _, t, _, last_t, interp_coeff) = new_state

    -- Interpolate to the target time.
    relative_output_time = (target_t - last_t) / (t - last_t)
    z_target = evalpoly interp_coeff relative_output_time
    (new_state, z_target)

  f0 = func z0 t0
  init_step = initial_step_size func t0 z0 4 rtol atol f0
  init_interp_coeff = zero  -- dummy vals
  init_carry = (z0, f0, t0, init_step, t0, init_interp_coeff)
  snd $ scan init_carry integrate_to_next_time


'#### Example: Linear dynamics

def myDyn (z : a) -> (t:Time) : a = z

z0 = [1.0]
t0 = 0.0
t1 = [1.0]

approx_e = odeint myDyn z0 t0 t1
:p approx_e

exact_e = [[exp 1.0]]

:p (approx_e - exact_e)

f0 = myDyn z0 t0
:p runge_kutta_step myDyn z0 f0 t0 1.0


times = linspace (Fin 100) 0.00001 1.0
ys = odeint myDyn z0 t0 times

:plot
  ys' = for i. ys.i.(fromOrdinal _ 0)
  zip times ys'
> <graphical output
