'# Adaptive Stochastic Differential Equation Solvers

import linalg
import linearmaps

UnitInterval = Float
Time = Float


'### Utility functions

def linear_interp {a} [VSpace a]
    (z0: a) (z1: a) (t0: Float) (t1: Float) (t: Float) : a =
  select (t1 == t0) z0 (z0 + ((t - t0) / (t1 - t0)) .* (z1 - z0))

def norm {d} (x: d=>Float) : Float = sqrt $ sum for i. sq x.i
def (./) {d} (x: d=>Float) (y: d=>Float) : d=>Float = for i. x.i / y.i

def prepend {v m} (first: v) (seq: m=>v) : (Unit | m )=>v =
  -- Concatenates a single element to the beginning of a sequence.
  for idx. case idx of
    Left _  -> first
    Right i -> seq.i

-- This typeclass will be obsolete once the `Basis` typeclass can be written.
interface HasStandardNormal a:Type
  randNormal : Key -> a

instance HasStandardNormal Float32
  randNormal = randn
instance {a n} [HasStandardNormal a] HasStandardNormal (n=>a)
  randNormal = \key.
    for i. randNormal (ixkey key i)



'## Virtual Brownian Tree
Memory-less sampler of Brownian motion.  Algorithm from
[Scalable Gradients for Stochastic Differential Equations](https://arxiv.org/abs/2001.01328)

def brownian_bridge_iter {v} [VSpace v, HasStandardNormal v]
  ((key, y, sigma, t):(Key & v & Float & UnitInterval)) :
    (Key & v & Float & UnitInterval) =
  -- Descend one step in a virtual Brownian tree.
    [kDraw, key_left, key_right] = split_key key
    t' = abs (t - 0.5)
    y' = sigma * (0.5 - t') .* randNormal kDraw
    key' = select (t > 0.5) key_left key_right
    (key', y + y', sigma / sqrt 2.0, t' * 2.0)

def sample_unit_brownian_motion {v} [VSpace v, HasStandardNormal v]
  (key:Key) (t:UnitInterval) : v =
  -- Brownian motion in interval (0.0, 1.0), where y(0.0) = 0.0
    (_, y, _, _) = fold (key, zero, 1.0, t) \i:(Fin 14). brownian_bridge_iter
    y

def scale_brownian_motion {v} [VSpace v] (f:Time -> v) (t0:Time) (t1:Time) (t:Time) : v =
  (sqrt (t1 - t0)) .* (f ((t - t0) / (t1 - t0)))

def sample_Brownian_motion {v} [VSpace v, HasStandardNormal v]
  (key:Key) (t0:Time) (t1:Time) (t:Time) : v =
  scale_brownian_motion (sample_unit_brownian_motion key) t0 t1 t



'## SDE Types

--data Time = MkTime Float

def Drift (v:Type) [VSpace v] : Type = v->Time->v
def Diffusion (m:Type) (v:Type) [LinearEndo m v] : Type =
  v->Time->m
def SDE (m:Type) (v:Type) [LinearEndo m v] : Type =
  (Drift v & Diffusion m v)

def radon_nikodym {m s} [InnerProd s, LinearEndo m s]
  (drift1:Drift s)
  (drift2:Drift s)
  (diffusion:Diffusion m s)
  (state:s) (t:Time) : Float =
  -- By Girsanov's theorem, this gives a simple Monte Carlo estimator
  -- of the (loosely speaking) instantaneous KL divergence between
  -- two SDEs that share a diffusion function.
  difference = (drift1 state t) - (drift2 state t)
  cur_diffusion = diffusion state t
  a = solve' cur_diffusion difference
  0.5 * inner_prod a a


'### Stationary SDEs
From Equation 3, Section 2.1 of ["A Complete Recipe for Stochastic Gradient
MCMC"](https://arxiv.org/pdf/1506.04696.pdf):
Every SDE with a stationary distribution can be parameterized
by:
 1. A state-dependent energy function
 2. A state-dependent skew-symmetric matrix
 3. A state-dependent diffusion matrix

'The function below converts these matrices into the drift and diffusion which,
if followed, will converge to a stationary distribution whose marginal
  log-density is equal to the negative energy function (plus a constant).

def StationaryDiffusion (m:Type) (v:Type) [LinearEndo m v] : Type = v->m
def NegEnergyFunc (v:Type) : Type = v->Float
def SkewSymmetricFunc (n:Type) (v:Type) [Ix n] : Type =
  v->(i:n=>(..<i)=>Float)
def StationarySDEParts (n:Type) (v:Type)
    [Ix n, LinearEndo n v, VSpace v] : Type =
  (NegEnergyFunc v & SkewSymmetricFunc n v & StationaryDiffusion n v)

def stationary_SDE_parts_to_SDE {n v}
  [Ix n, VSpace v, Mul v, LinearEndo n (n=>v)]
  ((neg_energy_func, skew_symm_map, diffusion_func):StationarySDEParts n (n=>v)) :
    (SDE n (n=>v)) =
  drift = \state time.

    diffusion_prod = \vec.  -- Square the root of the covariance matrix
      cur_diffusion_root = diffusion_func state
      0.5 .* (apply cur_diffusion_root (apply cur_diffusion_root vec))
  
    neg_energy_grad = (grad neg_energy_func) state

    skew_term = skew_symmetric_prod (skew_symm_map state) neg_energy_grad
    diff_term = diffusion_prod neg_energy_grad

    gammapart = \state.
      skew_term' = skew_symmetric_prod (skew_symm_map state) one
      diff_term' = diffusion_prod one
      skew_term' + diff_term'
    gamma_term = jvp gammapart state one
    
    skew_term + diff_term + gamma_term
  diffusion = \state time. diffusion_func state
  (drift, diffusion)




'## SDE Solvers

def ito_euler_step {v m} [LinearEndo m v] (sde: SDE m v) (z:v)
  (t:Time) (dt:Time) (noise:v) : (v & Time) =
  (drift, diffprod) = sde
  new_z = z + dt .* (drift z t) + apply (diffprod z t) noise
  (new_z, t + dt)

--def ito_milstein_step(y, t, args, noise, t_delta, f, g_prod, gdg_prod):
--    # Equation 20 from https://infoscience.epfl.ch/record/143450/files/sde_tutorial.pdf
--    return y + t_delta * f(y, t, args) + g_prod(y, t, args, noise) \
--           + 0.5 * gdg_prod(y, t, args, noise**2 - t_delta)

def ito_milstein_step {v m} [LinearEndo m v] (sde: SDE m v) (z:v)
  (t:Time) (dt:Time) (noise:v) : (v & Time) =
  -- Equation 20 from https://infoscience.epfl.ch/record/143450/files/sde_tutorial.pdf  
  (drift, diffprod) = sde
  --y + t_delta * f(y, t, args) + g_prod(y, t, args, noise) \
  --         + 0.5 * gdg_prod(y, t, args, noise**2 - t_delta)
  new_z = z + dt .* (drift z t) + 0.5 .* apply (diffprod z t) (sq noise)
  (new_z, t + dt)


--def strat_milstein_step(y, t, args, noise, t_delta, f, g_prod, gdg_prod):
--    # Equation 21 from https://infoscience.epfl.ch/record/143450/files/sde_tutorial.pdf
--    return y + t_delta * f(y, t, args) + g_prod(y, t, args, noise) \
--           + 0.5 * gdg_prod(y, t, args, noise**2)




def sdeint {d n} (sde: SDE (d=>Float))
           (initial_state: d=>Float) (t0: Time) (eval_times: n=>Time)
           (key: Key) : n=>d=>Float =
  --  eval_times must be strictly increasing.  Todo: enforce / automate.
  --  Returns:
  --    Values of a sampled trajectory at each time point in times.
  dt = 0.0001
  max_iters = 10000

  lasttime = maximum (prepend t0 eval_times)
  -- Todo: think about how to extend the BM beyond this interval later.
  noisefunc = \t. sample_Brownian_motion key t0 lasttime t

  integrate_to_next_time = \iter init_carry.
    target_t = eval_times.iter

    shouldContinue = \(_, _, _, t, dt).
      (t < target_t) && (dt > 0.0) && (ordinal iter < max_iters)

    step = \(old_z, old_t, z, t, dt).
      dB = (noisefunc (t + dt)) - (noisefunc t)
      (new_z, new_t) = ito_euler_step sde z t dt dB
      (z, t, new_z, new_t, dt)

    -- Take steps until we pass target_t
    new_state = yield_state init_carry \state.
      if shouldContinue (get state) then
        while do
          state := step (get state)
          shouldContinue (get state)
    (old_z, old_t, cur_z, cur_t, _) = new_state

    -- Interpolate to the target time.
    z_target = linear_interp old_z cur_z old_t cur_t target_t
    (new_state, z_target)

  init_carry = (initial_state, t0, initial_state, t0, dt)
  snd $ scan init_carry integrate_to_next_time

def error_ratio {d} (z_full:d=>Float) (z_half:d=>Float) (rtol:Float) (atol:Float) : Float =
  -- z_full obtained with one full step.
  -- z_half obtained with two half steps.
  eps = 1.0e-7
  tol = for i. max eps $ rtol * (max (abs z_full.i) (abs z_half.i)) + atol
  max eps $ norm $ (z_full - z_half) ./ tol

def step_size (error_estimate:Float)
              (prev_step_size:Time)
              (maybe_prev_error_ratio: Maybe Float) : (Float & Maybe Float) =
  safety=0.9
  facmin=0.2
  facmax=1.4
  (pfactor, ifactor) = case error_estimate > 1.0 of
    True -> (0.0, 1.0 / 1.5)
    False -> (0.13, 1.0 / 4.5)

  error_ratio = safety / error_estimate
  prev_error_ratio = case maybe_prev_error_ratio of
    Nothing -> error_ratio
    Just prev_error_ratio -> prev_error_ratio

  factor = pow error_ratio $ ifactor * ( pow (error_ratio / prev_error_ratio) pfactor)
    
  (prev_error_ratio, facmin) = case error_estimate <= 1.0 of
    True -> (error_ratio, 1.0)
    False -> (prev_error_ratio, facmin)

  factor = min facmax (max facmin factor)
  new_step_size = prev_step_size * factor
  (new_step_size, Just prev_error_ratio)

def adaptive_sdeint {d n} (sde: SDE (d=>Float))
           (z0: d=>Float) (t0: Time) (times: n=>Time)
           (key: Key) : n=>d=>Float =
  --  z0: the initial value for the state.
  --  t: times for evaluation. values must be strictly increasing.
  --  Returns:
  --    Values of the solution at each time point in times.
  rtol = 0.0001 --1.4e-7 -- relative local error tolerance for solver.
  atol = 0.00001 --1.4e-7 -- absolute local error tolerance for solver.
  max_iters = 10000
  init_dt = 1.0e-3

  lasttime = maximum (prepend t0 times)
  -- Todo: think about how to extend the BM beyond this interval later.
  noisefunc = \t. sample_Brownian_motion key t0 lasttime t

  integrate_to_next_time = \iter init_carry.
    target_t = times.iter

    shouldContinue = \(_, _, _, t, dt, _).
      (t < target_t) && (dt > 0.0) && (ordinal iter < max_iters)

    step = \(old_z, old_t, z, t, dt).
      dB = (noisefunc (t + dt)) - (noisefunc t)
      (new_z, new_t) = ito_euler_step sde z t dt dB
      (z, t, new_z, new_t, dt)

    possibly_step = \(old_z, old_t, z, t, dt, maybe_prev_error_ratio).
      -- Take 1 full step.
      (_, _, new_z_full, new_t, _) = step (old_z, old_t, z, t, dt)
      -- Take 2 half steps.
      (_, _, new_z_half, new_t_half, _) = step (old_z, old_t, z, t, dt / 2.0)
      (_, _, new_z_2xhf, _, _)          = step (old_z, old_t, new_z_half, new_t_half, dt / 2.0)

      ratio = error_ratio new_z_full new_z_2xhf rtol atol
      
      (new_dt, maybe_prev_error_ratio) = step_size ratio dt maybe_prev_error_ratio

      move_state = (z,     t,     new_z_2xhf, new_t, new_dt, maybe_prev_error_ratio)
      stay_state = (old_z, old_t, z,              t, new_dt, maybe_prev_error_ratio)
      select (ratio <= 1.0) move_state stay_state

    -- Take steps until we pass target_t
    new_state = yield_state init_carry \state.
      if shouldContinue (get state) then
        while do
          state := possibly_step (get state)
          shouldContinue (get state)
    (old_z, old_t, cur_z, cur_t, _, _) = new_state

    -- Interpolate to the target time.
    z_target = linear_interp old_z cur_z old_t cur_t target_t
    (new_state, z_target)

  init_carry = (z0, t0, z0, t0, init_dt, Nothing)
  snd $ scan init_carry integrate_to_next_time


'# Tests

import plot

'## Virtual Brownian Tree Tests
xs = linspace (Fin 10) 0.0 1.0
ys:(Fin 10)=>Float = for i. ((sample_unit_brownian_motion (new_key 0)) xs.i)
--:plot zip xs ys
:html show_plot $ xy_plot xs ys




def drift {v} (z: v=>Float) (t:Time): v=>Float = -z

def diffprod {v} (z:v=>Float) (t:Time) (noise:v=>Float): v=>Float = for i. noise.i

--sde = (drift, diffprod)

z0 = [1.0]
t0 = 0.1
times = linspace (Fin 10) 0.2 1.9
key = new_key 0

%time
yout = sdeint (drift, diffprod) z0 t0 times key

%time
yout' = adaptive_sdeint (drift, diffprod) z0 t0 times key

--:p yout - yout'

%time
:html show_plot $ xy_plot times for i. yout.i.(0@(Fin 1))

%time
:html show_plot $ xy_plot times for i. yout'.i.(0@(Fin 1))
