'# [Connectionist Temporal Classification](https://www.cs.toronto.edu/~graves/icml_2006.pdf)
By Alex Graves *et alia*, 2006.

'This algorithm computes the probability of a sequence of labels
(without pauses included) given another sequence of label probabilities
(with pauses included), marginalizing over all possible combination of
pause lengths.
It's used for training speech-to-text models on unaligned training data.

'Most implementations of CTC compute the log marginal likelihood
and its gradients through a separate forward and a backward pass.
However, Dex's autodiff can produce the backward
pass automatically.  That makes this code much shorter than
most implementations.

import stats  -- for LogSpace

'### Helper functions

IsBlank = Bool

def interleave {m v} (blank:v) (labels: m=>v) : (m & IsBlank)=>v =
  -- Turns "text" into "t e x t " by first pairing each letter with a blank,
  -- then flattening the pairs back into a single-index table.
  pairs = for i j. case j of
    True  -> blank
    False -> labels.i
  for (i, j). pairs.i.j

def prepend {m v} (first: v) (seq: m=>v) : ((Unit|m)=>v) =
  -- Concatenates a single element to the beginning of a sequence.
  for idx. case idx of
    Left () -> first
    Right i -> seq.i

def prepend_and_interleave {m v} (blank:v) (seq: m=>v) : ((Unit|(m & IsBlank))=>v) =
  -- Turns "text" into " t e x t ".
  prepend blank (interleave blank seq)

def normalize {n v} [Fractional v, Add v] (xs:n=>v) : n=>v =
  for i. divide xs.i (sum xs)


'### Main CTC algorithm
Computes p(labels | logits), marginalizing over possible alignments and
and marginalizes over insertion of blanks between characters.
Todo: add a `[Subset position time]` constraint.

def ctc_inner {vocab time position} [NonEmpty vocab, NonEmpty position, NonEmpty time, Eq time, Eq vocab]
    (blank: vocab)
    (logits: time=>vocab=>LogSpace Float)
    (labels: position=>vocab)
      : LogSpace Float =
  ilabels = prepend_and_interleave blank labels
  normalized_logits = for t. normalize logits.t

  -- Initialize dynamic programming table.
  logprob_start_with_blank = normalized_logits.first_ix.blank
  logprob_of_first_label   = normalized_logits.first_ix.(labels.first_ix)
  log_prob_seq_t0 = yield_state (for pos. Exp (-10000.0)) \lpRef.
    lpRef!(Left  first_ix) := logprob_start_with_blank
    lpRef!(Right first_ix) := logprob_of_first_label  -- 2nd index

  safe_idx_sub = \prev s y.
    if (ordinal s) < y
      then zero
      else prev.(unsafe_from_ordinal _ (unsafe_nat_diff (ordinal s) y))

  log_prob_seq_final = fold zero \t prev.
    case t == first_ix of
      True -> log_prob_seq_t0
      False -> for s.
        same_as_last = if (ordinal s) >= 2
          then ilabels.s == ilabels.(unsafe_from_ordinal _ ((ordinal s) -| 2))
          else False

        -- Equation 6 from CTC paper.
        ans = if ilabels.s == blank || same_as_last
          then prev.s + safe_idx_sub prev s 1
          else prev.s + safe_idx_sub prev s 1 + safe_idx_sub prev s 2
        ans * normalized_logits.t.(ilabels.s)

  -- Sum over last two entries in the dynamic programming table.
  last_label = log_prob_seq_final.(Right (last_ix, False))
  last_space = log_prob_seq_final.(Right (last_ix, True ))
  last_label + last_space


def ctc {vocab time position} [Eq time, Eq vocab]
    (blank: vocab)
    (logits: time=>vocab=>LogSpace Float)
    (labels: position=>vocab)
      : LogSpace Float =

  -- This is a wrapper function to check if any of the inputs are empty,
  -- and cast them into a provably `NonEmpty` form if not.
  -- If the compiler could generate `NonEmpty` instances for all
  -- Fin N where N > 0, this function would be unnecessary.
  if ((size vocab) > 0) && ((size time) > 0) && ((size position) > 0)
    then
      vocab_size_m1    = unsafe_nat_diff (size vocab) 1
      time_size_m1     = unsafe_nat_diff (size time) 1
      position_size_m1 = unsafe_nat_diff (size position) 1

      vocab'    = (Unit | Fin vocab_size_m1)
      time'     = (Unit | Fin time_size_m1)
      position' = (Unit | Fin position_size_m1)

      blank'  = unsafe_from_ordinal vocab' (ordinal blank)
      logits' = for t:time'. for v:vocab'. logits.(unsafe_from_ordinal _ (ordinal t)).(unsafe_from_ordinal _ (ordinal v))
      labels' = for p:position'.
        unsafe_from_ordinal _ (ordinal labels.(unsafe_from_ordinal _ (ordinal p)))
      
      ctc_inner blank' logits' labels'
    else zero

'## Demo

Vocab = Fin 6
blank:Vocab = 0@Vocab

-- Create random logits
Time = Fin 4
logits : Time => Vocab => (LogSpace Float) = arb $ new_key 0

-- Evaluate marginal probability of labels given logits
labels = [(3@Vocab), (4@Vocab), (1@Vocab)]
:p ls_to_f $ ctc blank logits labels
> 0.00209


'### Test

-- The CTC paper claims that the output of the above algorithm
-- computes p(labels|logits), which should sum to 1.0 over all possible labels.
-- They don't sum to one.  Maybe there is a bug in the above code
-- or the paper.

sum for i:Unit=>Vocab. ls_to_f $ ctc blank logits i
> 0.031206

-- (Fin N)=>Vocab is the set of all combinations of N tokens.
sum for i:((Fin 2)=>Vocab). ls_to_f $ ctc blank logits i
> 0.245854

sum for i:((Fin 3)=>Vocab). ls_to_f $ ctc blank logits i
> 0.565374
