'This is a demo of an MCMC sampler from the paper:
[Oops I Took A Gradient: Scalable Sampling for Discrete Distributions](https://arxiv.org/abs/2102.04509)
 demonstrated on an Ising model.

'The algorithm looks a lot like standard [Gibbs sampling](https://en.wikipedia.org/wiki/Gibbs_sampling),
but the dimension to be flipped is chosen based on the gradient
of the unnormalized density with respect to its inputs.
Although the inputs are discrete, the main idea of the
paper is to cheat and cast the function to one that 
has continuous inputs, so that the gradient is well-defined.
This might sound a bit hacky, but the resulting MCMC operator
still has the correct marginal distribution, since we apply
a [Metropolis-Hastings](https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm) correction step.


import plot

'### Helper Functions

instance Arbitrary Bool  -- Todo: Move to prelude.
  arb = \key. rand key < 0.5

def grad_and_value (f:a->Float) (x:a) : (a & Float) =
  (val, vjpfun) = vjp f x
  (vjpfun 1.0, val)

def flipEntry (x:n=>Bool) (flip_ix:n) : n=>Bool =
  yieldState x \xref.
    xref!flip_ix := not x.flip_ix


'## Standard Gibbs Sampler

def gibbsUpdate (x:n=>Bool) (f:n=>Bool->Float) (key:Key) : n=>Bool =
    
  [key_sample, key_accept] = splitKey key
  
  -- sample which dimension to change and flip it.
  flip_ix = randIdx key_sample
  x' = flipEntry x flip_ix

  -- accept / reject step.
  acceptance_rate = exp (f x' - f x)
  if rand key_accept < acceptance_rate
    then x'
    else x



'## Gibbs with Gradients Sampler

def boolToFloat (x:Bool) : Float =
  case x of
    True -> 1.0
    False -> -1.0

def floatToBool (x:Float) : Bool =
  select (x > 0.0) True False

def gibbsWithGradients (x:n=>Bool) (f:n=>Float->Float) (key:Key) : n=>Bool =
    
  [key_sample, key_accept] = splitKey key

  -- Compute proposal distribution.
  xFloat = map boolToFloat x
  (dfdx, fx) = grad_and_value f xFloat
  diff_x = -xFloat * dfdx
  log_qx'x = logsoftmax (diff_x / 2.0)

  -- sample which dimension to change and flip it.
  i = categorical log_qx'x key_sample
  x' = flipEntry x i

  -- Compute reverse transition distribution.
  xFloat' = map boolToFloat x'
  diff_x' = -xFloat' * dfdx
  log_qxx' = logsoftmax (diff_x' / 2.0)

  -- MH accept/reject.
  acceptance_rate = exp (f xFloat' - fx + log_qxx'.i - log_qx'x.i)
  if rand key_accept < acceptance_rate
    then x'
    else x


'## Ising Model

def wrapidx (n:Type) (i:Int) : n =
  asidx $ mod i $ size n  -- Index wrapping around at ends.

-- Increment/decrement index, wrapping around at ends.
def incwrap (i:n) : n = asidx $ mod ((ordinal i) + 1) $ size n
def decwrap (i:n) : n = asidx $ mod ((ordinal i) - 1) $ size n

def ising_logprob (x:n=>m=>Float) (bias:n=>m=>Float) (theta:Float) : Float =
  -- x is -1 or 1
  sum for (i, j).
    t1 = x.i.j * x.(incwrap i).j
    t2 = x.i.j * x.(decwrap i).j
    t3 = x.i.j * x.i.(incwrap j)
    t4 = x.i.j * x.i.(decwrap j)
    theta * (t1 + t2 + t3 + t4) + bias.i.j * x.i.j


'## Plotting utilities

def hue2rgb (p:Float) (q:Float) (t:Float) : Float = 
  t = t - floor t
  if t < (1.0/6.0)
    then p + (q - p) * 6.0 * t
    else if t < (1.0/2.0)
      then q
      else if t < (2.0/3.0)
        then p + (q - p) * (2.0/3.0 - t) * 6.0
        else p

def hslToRgb (h:Float) (s:Float) (l:Float) : Color =
  if s == 0.0
    then [l, l, l] -- achromatic
    else
      q = select (l < 0.5) (l * (1.0 + s)) (l + s - l * s)
      p = 2.0 * l - q
      r = hue2rgb p q (h + 1.0/3.0)
      g = hue2rgb p q h
      b = hue2rgb p q (h - 1.0/3.0)
      [r, g, b]

def probToColor (x:Bool) (grad:Float) : Color =
  -- For visualizing the probability that a given bit will flip.
  -- Turns pixels red if they have a high chance of flipping.

  scaled_change_prob = clip (0.0, 1.0) (100.0 * grad)
  
  hue = 0.0         -- red
  saturation = 1.0  -- fully saturated
  lightness = case x of
    True -> scaled_change_prob
    False -> 1.0 - scaled_change_prob

  hslToRgb hue saturation lightness


def pngsToSavedGif (delay:Int) (pngs:t=>Png) (outFileName:String) : Gif =
  unsafeIO \().
    withTempFiles \pngFiles.
      for i.
        writeFile pngFiles.i pngs.i
      shellOut $
        "convert" <> " -delay " <> show delay <> " " <>
        concat (for i. "png:" <> pngFiles.i <> " ") <>
        "gif:" <> outFileName <> ".gif"


'## Set up a particular Ising model

png = unsafeIO do
  readFile "examples/peace.png"

:t png

theta = 0.5
N = Fin 60
x : (N & N)=>Bool = arb (newKey 0)

def flattened_ising (x:n=>Float) : Float =
  -- unflattens x.  
  xu = for i:N. for j:N.
    x.(unsafeFromOrdinal _ (ordinal (i,j)))
  ising_logprob xu theta


'## Generate images

'### Gibbs with Gradients

def runSampler (samplerStep: n=>Bool -> (n=>Float->Float) -> Key -> (n=>Bool))
  (init:n=>Bool) (f:n=>Float -> Float)
  (iters:Int) (writePeriod:Int) : List (n=>Bool) =
  yieldAccum (ListMonoid (n=>Bool)) \list.
    yieldState init \state.
      for i:(Fin iters).
        x = get state
        state := samplerStep x f (newKey (ordinal i))
        if mod (ordinal i) writePeriod == 0 then
          append list x

num_iters = 1000
write_period = 100

xmovie' = runSampler gibbsWithGradients x flattened_ising num_iters write_period
(AsList _ xmovie) = xmovie'
xmovieflat:(Fin _)=>N=>N=>Color =
  for i.
    xf = map boolToFloat xmovie.i
    dfdx = grad flattened_ising xf
    flip_prob = softmax (-xf * dfdx / 2.0)
    for j k. probToColor xmovie.i.(j, k) flip_prob.(j, k)

:html imseqshow xmovieflat
pngsToSavedGif 1 (map imgToPng xmovieflat) "gwg"


'### Standard Gibbs

def wrappedGibbs (x:n=>Bool) (f:n=>Float->Float) (key:Key) : n=>Bool =
  boolf = \x'.
    f $ map boolToFloat x'
    
  gibbsUpdate x boolf key

xmovie'' = runSampler wrappedGibbs x flattened_ising num_iters write_period
(AsList _ xmovie''') = xmovie''
xmovieflat':(Fin _)=>N=>N=>Color =
  for i.
    xf = map boolToFloat xmovie'''.i
    dfdx = 1.0
    flip_prob = 1.0 / ( sq $ IToF (size N))
    for j k. probToColor xmovie'''.i.(j, k) flip_prob

:html imseqshow xmovieflat'
pngsToSavedGif 1 (map imgToPng xmovieflat') "gibbs"

