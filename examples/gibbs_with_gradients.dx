'# Gibbs with Gradients

'This is a demo of an MCMC sampler from the paper:
[Oops I Took A Gradient: Scalable Sampling for Discrete Distributions](https://arxiv.org/abs/2102.04509)
 demonstrated on an Ising model.

'The algorithm looks a lot like standard [Gibbs sampling](https://en.wikipedia.org/wiki/Gibbs_sampling),
but the dimension to be flipped is chosen based on the gradient
of the unnormalized density with respect to its inputs.
Although the inputs are discrete, the main idea of the
paper is to cheat and cast the function to one that 
has continuous inputs, so that the gradient is well-defined.
This might sound a bit hacky, but the resulting MCMC operator
still has the correct marginal distribution, since we apply
a [Metropolis-Hastings](https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm) correction step.

'This demo uses the Ising model for image denoising.


import parser
import plot


'### Helper Functions

def grad_and_value (f:a->Float) (x:a) : (a & Float) =
  (val, vjpfun) = vjp f x
  (vjpfun 1.0, val)

def flipEntry (x:n=>Bool) (flip_ix:n) : n=>Bool =
  yieldState x \xref.
    xref!flip_ix := not x.flip_ix


'## Standard Gibbs Sampler

def gibbsUpdate (x:n=>Bool) (f:n=>Bool->Float) (key:Key) : n=>Bool =
    
  [key_sample, key_accept] = splitKey key
  
  -- Sample which dimension to change and flip it.
  flip_ix = randIdx key_sample
  x' = flipEntry x flip_ix

  -- Accept / reject step.
  acceptance_rate = exp (f x' - f x)
  if rand key_accept < acceptance_rate
    then x'
    else x



'## Gibbs with Gradients Sampler

'The Gibbs with Gradients sampler has a slightly different function signature
than standard Gibbs.  Instead of its log probability function taking in a
discrete array, it takes in an array of floats of the same size.  This is necessary
so that it can be differentiated with respect to its input, even though we will
only call it on discrete inputs.

def boolToFloat (x:Bool) : Float =
  case x of
    True -> 1.0
    False -> -1.0

def floatToBool (x:Float) : Bool =
  select (x > 0.0) True False

def gibbsWithGradients (x:n=>Bool) (f:n=>Float->Float) (key:Key) : n=>Bool =
  [key_sample, key_accept] = splitKey key

  -- Compute proposal distribution.
  xFloat = map boolToFloat x
  (dfdx, fx) = grad_and_value f xFloat
  diff_x = -xFloat * dfdx
  log_qx'x = logsoftmax (diff_x / 2.0)

  -- sample which dimension to change and flip it.
  i = categorical log_qx'x key_sample
  x' = flipEntry x i

  -- Compute reverse transition distribution.
  xFloat' = map boolToFloat x'
  diff_x' = -xFloat' * dfdx
  log_qxx' = logsoftmax (diff_x' / 2.0)

  -- MH accept/reject.
  acceptance_rate = exp (f xFloat' - fx + log_qxx'.i - log_qx'x.i)
  if rand key_accept < acceptance_rate
    then x'
    else x


'## Ising Model

def wrapidx (n:Type) (i:Int) : n =
  asidx $ mod i $ size n  -- Index wrapping around at ends.

-- Increment/decrement index, wrapping around at ends.
def incwrap (i:n) : n = asidx $ mod ((ordinal i) + 1) $ size n
def decwrap (i:n) : n = asidx $ mod ((ordinal i) - 1) $ size n

def ising_logprob (x:n=>m=>Float) (bias:n=>m=>Float) (theta:Float) : Float =
  -- x is -1 or 1
  sum for (i, j).
    t1 = x.i.j * x.(incwrap i).j
    t2 = x.i.j * x.(decwrap i).j
    t3 = x.i.j * x.i.(incwrap j)
    t4 = x.i.j * x.i.(decwrap j)
    theta * (t1 + t2 + t3 + t4) + bias.i.j * x.i.j


'## Plotting utilities

def runSampler (samplerStep: n=>Bool -> (n=>Float->Float) -> Key -> (n=>Bool))
  (init:n=>Bool) (f:n=>Float -> Float)
  (iters:Int) (writePeriod:Int) : List (n=>Bool) =
  yieldAccum (ListMonoid (n=>Bool)) \list.
    yieldState init \state.
      for i:(Fin iters).
        x = get state
        state := samplerStep x f (newKey (ordinal i))
        if mod (ordinal i) writePeriod == 0 then
          append list x

def hue2rgb (p:Float) (q:Float) (t:Float) : Float = 
  t = t - floor t
  if t < (1.0/6.0)
    then p + (q - p) * 6.0 * t
    else if t < (1.0/2.0)
      then q
      else if t < (2.0/3.0)
        then p + (q - p) * (2.0/3.0 - t) * 6.0
        else p

def hslToRgb (h:Float) (s:Float) (l:Float) : Color =
  if s == 0.0
    then [l, l, l] -- achromatic
    else
      q = select (l < 0.5) (l * (1.0 + s)) (l + s - l * s)
      p = 2.0 * l - q
      r = hue2rgb p q (h + 1.0/3.0)
      g = hue2rgb p q h
      b = hue2rgb p q (h - 1.0/3.0)
      [r, g, b]

def probToColor (x:Bool) (grad:Float) : Color =
  -- For visualizing the probability that a given bit will flip.
  -- Turns pixels red if they have a high chance of flipping.

  scaled_change_prob = clip (0.0, 1.0) (100.0 * grad)
  
  hue = 0.0         -- red
  saturation = 1.0  -- fully saturated
  lightness = case x of
    True -> scaled_change_prob
    False -> 1.0 - scaled_change_prob

  hslToRgb hue saturation lightness


def pngsToSavedGif (delay:Int) (pngs:t=>Png) (outFileName:String) : Gif =
  unsafeIO \().
    withTempFiles \pngFiles.
      for i.
        writeFile pngFiles.i pngs.i
      shellOut $
        "convert" <> " -delay " <> show delay <> " " <>
        concat (for i. "png:" <> pngFiles.i <> " ") <>
        "gif:" <> outFileName <> ".gif"


'### Image Loading Utilities
This is a nice chance to try out Dex's simpler parser combinator library.

def parseP6header : Parser (Int & Int & Int) = MkParser \h.
  -- Loads a raw PPM file in P6 format.
  -- The header will look something like:
  --P6
  --220 220    (height, width)
  --255        (max color value)
  -- followed by a flat block of height x width x 3 chars.
  parse h $ pChar 'P'
  parse h $ pChar '6'
  parse h $ parseAny
  rows = parse h $ parseUnsignedInt
  parse h $ parseAny
  cols = parse h $ parseUnsignedInt
  parse h $ parseAny
  colorsize = parse h $ parseUnsignedInt
  (rows, cols, colorsize)

def parseP6 (rows:Int) (cols:Int) : Parser ((Fin rows)=>(Fin cols)=>(Fin 3)=>Char) = MkParser \h.
  parse h $ parseP6header
  parse h $ parseAny
  for r:(Fin rows).
    for c:(Fin cols).
      for c:(Fin 3).
        parse h parseAny

def pixelToBool (x:Char) : Bool = (W8ToI x) < 0


'### Load image

image_raw = unsafeIO do readFile "examples/peace.ppm"
(rows, cols, _) = fromJust $ runParserPartial image_raw parseP6header
image = fromJust $ runParserPartial image_raw (parseP6 rows cols)
image_bool = for i j.
  pixelToBool image.i.j.(1@_)

-- Add noise
noisefrac = 0.1
image_noisy = for i j.
  addnoise = rand (ixkey2 (newKey 0) i j) < noisefrac
  case addnoise of
    True -> not image_bool.i.j
    False -> image_bool.i.j

imcol = for i j. for c:(Fin 3).
  (IToF $ BToI $ not image_bool.i.j)

'### Set up an Ising model to denoise that image.
'The model simply encodes that nearby pixels usually have the same color.
'The bias term makes it more likely that the pixels will match the noisy image.

theta = 0.5  -- Coupling constant between neighbouring pixels.
bias = for i j.  -- Bias for individual pixels.
  case image_noisy.i.j of
    True -> 1.0
    False -> -1.0

def flattened_ising (x:n=>Float) : Float =
  -- unflattens x.
  x_unflattend = for i j.
    x.(unsafeFromOrdinal _ (ordinal (i,j)))
  ising_logprob x_unflattend bias theta

'Normally for image denoising, we start with the noisy image.
However, to simulate a more realistic inference problem,
we'll start far from the mode at a completely random initialization.

init_field =
  for (i, j):((Fin rows) & (Fin cols)).
    rand (ixkey2 (newKey 0) i j) < 0.5

'## Generate animations

'### Run Gibbs with Gradients
We'll color the pixels by the probability that they'll be proposed to flip.
In an Ising model, this creates an outline around the edges of homoeneous regions.

num_iters = 175  -- Change to 17500 for full animation.
write_period = 50

frameList = runSampler gibbsWithGradients init_field flattened_ising num_iters write_period
(AsList _ xmovie) = frameList
xmovieflat = for i.
    xf = map boolToFloat xmovie.i
    dfdx = grad flattened_ising xf
    flip_prob = softmax (-xf * dfdx / 2.0)  -- Color pixels by probability of flipping.
    for j k. probToColor xmovie.i.(j, k) flip_prob.(j, k)

:html imseqshow xmovieflat
pngsToSavedGif 1 (map imgToPng xmovieflat) "gwg"


'### Run Standard Gibbs

'So that we can re-use the helper function for Gibbs with Gradients,
we need to change the signature of standard Gibbs to match.

def wrappedGibbs (x:n=>Bool) (f:n=>Float->Float) (key:Key) : n=>Bool =
  boolf:(n=>Bool->Float) = \x'.
    f $ map boolToFloat x'
  gibbsUpdate x boolf key

frameList' = runSampler wrappedGibbs init_field flattened_ising num_iters write_period
(AsList _ xmovie') = frameList'
xmovieflat' = for i.
    xf = map boolToFloat xmovie'.i
    flip_prob = 1.0 / (IToF (rows * cols))  -- Uniform probability of flipping.
    for j k. probToColor xmovie'.i.(j, k) flip_prob

:html imseqshow xmovieflat'
pngsToSavedGif 1 (map imgToPng xmovieflat') "gibbs"

'And we see Gibbs with gradients mixes faster.
The improvement will generally grow with problem size.
