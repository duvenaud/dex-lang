'## Linear Algebra
- Cholesky Decomposition
- LU Decomposition
- Matrix Inversion


def unsafe_cast {a m} [Ix a, Ix m] (d:a) : m = unsafe_from_ordinal m (ordinal d)
def unsafe_first_ix {n} [Ix n] : n = unsafe_from_ordinal n 0
def unsafe_last_ix  {n} [Ix n] : n = unsafe_from_ordinal n (unsafe_nat_diff (size n) 1)

def first_ix_of {n} [Ix n] (x:n) : n =
  -- This function is safe because one can't produce an element of type n
  -- if there isn't at least one possible value in its type. So being able
  -- to produce x to call this function is proof that `n` is non-empty.
  unsafe_from_ordinal n 0

def last_ix_of {n} [NonEmpty n] (x:n) : n =
  unsafe_from_ordinal _ $ unsafe_i_to_n $ n_to_i (size n) - 1

def is_last {n} [Ix n] (x:n) : Bool =
  ((ordinal x) + 1) == size n


'### Triangular matrices

def LowerTriMat (n:Type) [Ix n] (v:Type) : Type = i:n=>(..i)=>v
def UpperTriMat (n:Type) [Ix n] (v:Type) : Type = i:n=>(i..)=>v

def upper_tri_diag {n v} (u:UpperTriMat n v) : n=>v = view i. u.i.unsafe_first_ix
def lower_tri_diag {n v} (l:LowerTriMat n v) : n=>v = view i. l.i.unsafe_last_ix

def lower_tri_identity {a n} [Ix n, Add a, Mul a] : LowerTriMat n a =
  for i j. select (is_last j) one zero

def transpose_lower_to_upper {n v} (lower:LowerTriMat n v) : UpperTriMat n v =
  for i:n. for j':(i..).
    j = inject n j'
    lower.j.(unsafe_cast i)

def transpose_lower_to_upper_no_diag {n v}
    (lower:i:n=>(..<i)=>v) :
           i:n=>(i<..)=>v =
  for i j.
    j' = inject n j
    lower.j'.(unsafe_cast i)

def skew_symmetric_prod {v n} [VSpace v]
    (lower: i:n=>(..<i)=>Float) (y: n=>v) : n=>v =
  upper = transpose_lower_to_upper_no_diag lower
  -- We could probably fuse these two for loops.
  lower_prod = for i. sum for j. lower.i.j .* (y.(inject n j))
  upper_prod = for i. sum for j. upper.i.j .* (y.(inject n j))
  lower_prod - upper_prod

def forward_substitute {n v} [VSpace v] (a:LowerTriMat n Float) (b:n=>v) : n=>v =
  -- Solves lower triangular linear system (inverse a) **. b
  yield_state zero \sRef.
    for i:n.
      s = sum for k:(..<i).  -- dot product
        a.i.(unsafe_cast k) .* get sRef!(inject n k)
      sRef!i := (b.i - s) / (lower_tri_diag a).i

def backward_substitute {n v} [VSpace v] (a:UpperTriMat n Float) (b:n=>v) : n=>v =
  -- Solves upper triangular linear system (inverse a) **. b
  yield_state zero \sRef.
    rof i:n.
      s = sum for k:(i..).  -- dot product
        a.i.(unsafe_cast k) .* get sRef!(inject n k)
      sRef!i := (b.i - s) / (upper_tri_diag a).i

-- Todo: get rid of these by writing a dependent indexing (!) operator.
def lower_tri_mat {a b h} (ref:Ref h (LowerTriMat a b)) (i:a) (j:(..i)) : Ref h b =
  d = %indexRef ref i
  d!j
def upper_tri_mat {a b h} (ref:Ref h (UpperTriMat a b)) (i:a) (j:(i..)) : Ref h b =
  d = %indexRef ref i
  d!j

'### Cholesky decomposition

def chol {n} (x:n=>n=>Float) : LowerTriMat n Float =
  yield_state zero \buf.
    mat = lower_tri_mat buf
    for i:n. for j':(..i).
      j = inject n j'
      row  = for k:(..<j). get $ mat i (unsafe_cast k)
      row' = for k:(..<j). get $ mat j (unsafe_cast k)
      a = x.i.j - vdot row row'
      if (ordinal i) == (ordinal j)
        then
          mat i j' := sqrt a
        else
          b = get $ mat j (unsafe_cast j')
          mat i j' := a / b

'### Permutations

-- The sign of the determinant of a permutation is either 1.0 or -1.0
PermutationSign = Float

def Permutation (n:Type) [Ix n] : Type = (perm:n=>n & PermutationSign)

def apply_permutation {n t} ((perm, _):Permutation n) (xs: n=>t) : n=>t =
  for i. xs.(perm.i)

def identity_permutation {n} [Ix n] : Permutation n =
  (for i. i, 1.0)

def swap_in_place {n h} (pRef: Ref h (Permutation n)) (i:n) (j:n) : {State h} Unit =
  (permRef, signRef) = (fst_ref pRef, snd_ref pRef)
  tempj = get permRef!j
  permRef!j := get permRef!i
  permRef!i := tempj
  signRef := -(get signRef)

def perm_to_table {n} ((perm, _):Permutation n) : n=>n = perm
def perm_sign    {n} ((_, sign):Permutation n) : PermutationSign = sign


'### LU decomposition functions

def pivotize {n} (a:n=>n=>Float) : Permutation n =
  -- Gives a row permutation that makes Gaussian elimination more stable.
  yield_state identity_permutation \permRef.
    for j:n.
      row_with_largest = argmin for i:(j..). (-(abs a.(inject n i).j))
      if (ordinal j) /= (ordinal row_with_largest) then
        swap_in_place permRef j (inject n row_with_largest)

def lu {n} (a: n=>n=>Float) :
       (LowerTriMat n Float & UpperTriMat n Float & Permutation n) =
  -- Computes lower, upper, and permuntation matrices from a square matrix,
  -- such that apply_permutation permutation a == lower ** upper.
  permutation = pivotize a
  a = apply_permutation permutation a

  init_lower = lower_tri_identity
  init_upper = zero

  (lower, upper) = yield_state (init_lower, init_upper) \stateRef.
    lRef = fst_ref stateRef
    uRef = snd_ref stateRef

  -- For reference, here's code to computed the LU decomposition
  -- without dependent tables (i.e. with standard flat matrices):
  --  for j:n.
  --    for i:(..j).
  --      i = inject _ i
  --      s = sum for k':(..i).
  --        k = inject _ k'
  --        (get uRef!k!j) * (get lRef!i!k)
  --      uRef!i!j := a.i.j - s

  --    for i':(j<..).
  --      i = inject _ i'
  --      s = sum for k':(..j).
  --        k = inject _ k'
  --        (get uRef!k!j) * (get lRef!i!k)
  --      lRef!i!j := (a.i.j - s) / (get uRef!j!j)
  --    for i:n. ()

    -- Helper functions to index into triangular matrices
    -- from indices that themselves need to be cast or projected
    -- to the right type.
    def lmat {m} (i:n) (j:m) [Ix m] : Ref _ Float =
      lower_tri_mat lRef i $ unsafe_cast j
    def umat {m} (i:n) (j:m) [Ix m, Subset (i..) m] : Ref _ Float =
      upper_tri_mat uRef i $ from_just (project (i..) j)

    for j:n.
      for i:(..j).
        i' = inject n i
        s = sum for k:(..i).
          -- TODO: get transitivity of Subset working so we can do a single injection
          k' = inject n (inject (..j) k)
          ukj = get $ umat k' j
          lik = get $ lmat i' k
          ukj * lik

        umat i' j := a.(inject _ i).j - s

      for i:(j<..).
        i' = inject n i
        s = sum for k:(..j).
          k' = inject n k
          ukj = get $ umat k' j
          lik = get $ lmat i' k
          ukj * lik

        ujj = get $ umat j j
        i'' = unsafe_cast i'
        lmat i'' j := (a.i'.j - s) / ujj
  (lower, upper, permutation)


'### General linear algebra functions.

def solve {n v} [VSpace v] (a:n=>n=>Float) (b:n=>v) : n=>v =
  -- There's a small speedup possible by exploiting the fact
  -- that l always has ones on the diagonal.  It would just require a
  -- custom forward_substitute routine that doesn't divide
  -- by the diagonal entries.
  (l, u, perm) = lu a
  b' = apply_permutation perm b
  y = forward_substitute l b'
  backward_substitute u y

def invert {n} (a:n=>n=>Float) : n=>n=>Float =
  solve a eye

def determinant {n} (a:n=>n=>Float) : Float =
  (l, u, perm) = lu a
  prod (for i. (upper_tri_diag u).i * (lower_tri_diag l).i) * perm_sign perm

def sign_and_log_determinant {n} (a:n=>n=>Float) : (Float & Float) =
  (l, u, perm) = lu a
  diags = for i. (upper_tri_diag u).i * (lower_tri_diag l).i
  sign = (perm_sign perm) * prod for i. sign diags.i
  sum_of_log_abs = sum for i. log (abs diags.i)
  (sign, sum_of_log_abs)

def matrix_power {n} (base:n=>n=>Float) (power:Nat) : n=>n=>Float =
  general_integer_power (**) eye base power

def trace {n a} [Add a] (x:n=>n=>a) : a =
  sum for i. x.i.i
